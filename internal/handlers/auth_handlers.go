package handlers

import (
	"encoding/json"
	"errors"
	"net/http"
	"strings"

	"loopgate/internal/auth"
	"loopgate/internal/storage"
	"loopgate/internal/types"

	"github.com/google/uuid"
)

// AuthHandlers holds dependencies for authentication handlers.
type AuthHandlers struct {
	Storage   storage.StorageAdapter
	JWTSecret string
}

// NewAuthHandlers creates a new AuthHandlers.
func NewAuthHandlers(storage storage.StorageAdapter, jwtSecret string) *AuthHandlers {
	return &AuthHandlers{
		Storage:   storage,
		JWTSecret: jwtSecret,
	}
}

// RegisterUserRequest defines the expected JSON structure for user registration.
type RegisterUserRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// LoginUserRequest defines the expected JSON structure for user login.
type LoginUserRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// LoginUserResponse defines the JSON structure for a successful login response.
type LoginUserResponse struct {
	Token string `json:"token"`
	UserID uuid.UUID `json:"user_id"`
	Username string `json:"username"`
}

// RegisterUserHandler handles user registration.
// POST /api/auth/register
func (h *AuthHandlers) RegisterUserHandler(w http.ResponseWriter, r *http.Request) {
	var req RegisterUserRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		return
	}
	defer r.Body.Close()

	req.Username = strings.TrimSpace(req.Username)
	if req.Username == "" || req.Password == "" {
		http.Error(w, "Username and password cannot be empty", http.StatusBadRequest)
		return
	}

	// Basic validation (can be extended)
	if len(req.Password) < 8 {
		http.Error(w, "Password must be at least 8 characters long", http.StatusBadRequest)
		return
	}

	// Check if user already exists
	_, err := h.Storage.GetUserByUsername(req.Username)
	if err == nil {
		http.Error(w, "Username already exists", http.StatusConflict)
		return
	}
	// We expect "user not found" error here, any other error is a server issue
	if err != nil && !strings.Contains(err.Error(), "user not found") {
		http.Error(w, "Failed to check user existence: "+err.Error(), http.StatusInternalServerError)
		return
	}


	hashedPassword, err := auth.HashPassword(req.Password)
	if err != nil {
		http.Error(w, "Failed to hash password", http.StatusInternalServerError)
		return
	}

	newUser := &types.User{
		// ID will be generated by storage adapter if uuid.Nil
		Username:     req.Username,
		PasswordHash: hashedPassword,
	}

	if err := h.Storage.CreateUser(newUser); err != nil {
		http.Error(w, "Failed to create user: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(map[string]string{"message": "User registered successfully", "user_id": newUser.ID.String()})
}

// LoginUserHandler handles user login.
// POST /api/auth/login
func (h *AuthHandlers) LoginUserHandler(w http.ResponseWriter, r *http.Request) {
	var req LoginUserRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		return
	}
	defer r.Body.Close()

	if req.Username == "" || req.Password == "" {
		http.Error(w, "Username and password cannot be empty", http.StatusBadRequest)
		return
	}

	user, err := h.Storage.GetUserByUsername(req.Username)
	if err != nil {
		if strings.Contains(err.Error(), "user not found") {
			http.Error(w, "Invalid username or password", http.StatusUnauthorized)
		} else {
			http.Error(w, "Failed to retrieve user", http.StatusInternalServerError)
		}
		return
	}

	if !auth.CheckPasswordHash(req.Password, user.PasswordHash) {
		http.Error(w, "Invalid username or password", http.StatusUnauthorized)
		return
	}

	tokenString, err := auth.GenerateJWT(user.ID, user.Username, h.JWTSecret)
	if err != nil {
		http.Error(w, "Failed to generate token: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(LoginUserResponse{
		Token: tokenString,
		UserID: user.ID,
		Username: user.Username,
	})
}

// Helper to extract user ID from JWT claims in context (to be used by other handlers)
// This would typically be set by a JWT authentication middleware.
func GetUserClaimsFromContext(r *http.Request) (*types.Claims, error) {
	claims, ok := r.Context().Value("userClaims").(*types.Claims)
	if !ok || claims == nil {
		return nil, errors.New("user claims not found in context, ensure JWTAuthMiddleware is used")
	}
	return claims, nil
}
